"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minipass";
exports.ids = ["vendor-chunks/minipass"];
exports.modules = {

/***/ "(rsc)/./node_modules/minipass/dist/commonjs/index.js":
/*!******************************************************!*\
  !*** ./node_modules/minipass/dist/commonjs/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n    };\nconst node_events_1 = __webpack_require__(/*! node:events */ \"node:events\");\nconst node_stream_1 = __importDefault(__webpack_require__(/*! node:stream */ \"node:stream\"));\nconst node_string_decoder_1 = __webpack_require__(/*! node:string_decoder */ \"node:string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nconst isStream = (s) => !!s &&\n    typeof s === 'object' &&\n    (s instanceof Minipass ||\n        s instanceof node_stream_1.default ||\n        (0, exports.isReadable)(s) ||\n        (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nconst isReadable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.pipe === 'function' &&\n    // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== node_stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nconst isWritable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.write === 'function' &&\n    typeof s.end === 'function';\nexports.isWritable = isWritable;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = (fn) => Promise.resolve().then(fn);\nconst nodefer = (fn) => fn();\nconst isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = (b) => b instanceof ArrayBuffer ||\n    (!!b &&\n        typeof b === 'object' &&\n        b.constructor &&\n        b.constructor.name === 'ArrayBuffer' &&\n        b.byteLength >= 0);\nconst isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n    src;\n    dest;\n    opts;\n    ondrain;\n    constructor(src, dest, opts) {\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = () => src[RESUME]();\n        this.dest.on('drain', this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener('drain', this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */\n    proxyErrors(_er) { }\n    /* c8 ignore stop */\n    end() {\n        this.unpipe();\n        if (this.opts.end)\n            this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener('error', this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts) {\n        super(src, dest, opts);\n        this.proxyErrors = er => dest.emit('error', er);\n        src.on('error', this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o) => !!o.objectMode;\nconst isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nclass Minipass extends node_events_1.EventEmitter {\n    [FLOWING] = false;\n    [PAUSED] = false;\n    [PIPES] = [];\n    [BUFFER] = [];\n    [OBJECTMODE];\n    [ENCODING];\n    [ASYNC];\n    [DECODER];\n    [EOF] = false;\n    [EMITTED_END] = false;\n    [EMITTING_END] = false;\n    [CLOSED] = false;\n    [EMITTED_ERROR] = null;\n    [BUFFERLENGTH] = 0;\n    [DESTROYED] = false;\n    [SIGNAL];\n    [ABORTED] = false;\n    [DATALISTENERS] = 0;\n    [DISCARDED] = false;\n    /**\n     * true if the stream can be written\n     */\n    writable = true;\n    /**\n     * true if the stream can be read\n     */\n    readable = true;\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */\n    constructor(...args) {\n        const options = (args[0] ||\n            {});\n        super();\n        if (options.objectMode && typeof options.encoding === 'string') {\n            throw new TypeError('Encoding and objectMode may not be used together');\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        }\n        else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        }\n        else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING]\n            ? new node_string_decoder_1.StringDecoder(this[ENCODING])\n            : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            }\n            else {\n                signal.addEventListener('abort', () => this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */\n    get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */\n    get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */\n    set encoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */\n    setEncoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * True if this is an objectMode stream\n     */\n    get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */\n    set objectMode(_om) {\n        throw new Error('objectMode must be set at instantiation time');\n    }\n    /**\n     * true if this is an async stream\n     */\n    get ['async']() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */\n    set ['async'](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit('abort', this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */\n    get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */\n    set aborted(_) { }\n    write(chunk, encoding, cb) {\n        if (this[ABORTED])\n            return false;\n        if (this[EOF])\n            throw new Error('write after end');\n        if (this[DESTROYED]) {\n            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));\n            return true;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            }\n            else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            }\n            else if (typeof chunk !== 'string') {\n                throw new Error('Non-contiguous data written to non-objectMode stream');\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */\n            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n                this[FLUSH](true);\n            /* c8 ignore stop */\n            if (this[FLOWING])\n                this.emit('data', chunk);\n            else\n                this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === 'string' &&\n            // unless it is a string already ready for us to use\n            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n            this[FLUSH](true);\n        if (this[FLOWING])\n            this.emit('data', chunk);\n        else\n            this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0)\n            this.emit('readable');\n        if (cb)\n            fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */\n    read(n) {\n        if (this[DESTROYED])\n            return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 ||\n            n === 0 ||\n            (n && n > this[BUFFERLENGTH])) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE])\n            n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                (this[ENCODING]\n                    ? this[BUFFER].join('')\n                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null)\n                this[BUFFERSHIFT]();\n            else if (typeof c === 'string') {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n            else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit('data', chunk);\n        if (!this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (chunk !== undefined)\n            this.write(chunk, encoding);\n        if (cb)\n            this.once('end', cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED])\n            this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED])\n            return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit('resume');\n        if (this[BUFFER].length)\n            this[FLUSH]();\n        else if (this[EOF])\n            this[MAYBE_EMIT_END]();\n        else\n            this.emit('drain');\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */\n    resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */\n    pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */\n    get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */\n    get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */\n    get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] += 1;\n        else\n            this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] -= 1;\n        else\n            this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n            this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit('data', chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */\n    pipe(dest, opts) {\n        if (this[DESTROYED])\n            return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr)\n            opts.end = false;\n        else\n            opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end)\n                dest.end();\n        }\n        else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors\n                ? new Pipe(this, dest, opts)\n                : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC])\n                defer(() => this[RESUME]());\n            else\n                this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    unpipe(dest) {\n        const p = this[PIPES].find(p => p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            }\n            else\n                this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */\n    addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */\n    on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === 'data') {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        }\n        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n            super.emit('readable');\n        }\n        else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        }\n        else if (ev === 'error' && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC])\n                defer(() => h.call(this, this[EMITTED_ERROR]));\n            else\n                h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */\n    removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === 'data') {\n            this[DATALISTENERS] = this.listeners('data').length;\n            if (this[DATALISTENERS] === 0 &&\n                !this[DISCARDED] &&\n                !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */\n    removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === 'data' || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */\n    get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] &&\n            !this[EMITTED_END] &&\n            !this[DESTROYED] &&\n            this[BUFFER].length === 0 &&\n            this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit('end');\n            this.emit('prefinish');\n            this.emit('finish');\n            if (this[CLOSED])\n                this.emit('close');\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */\n    emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== 'error' &&\n            ev !== 'close' &&\n            ev !== DESTROYED &&\n            this[DESTROYED]) {\n            return false;\n        }\n        else if (ev === 'data') {\n            return !this[OBJECTMODE] && !data\n                ? false\n                : this[ASYNC]\n                    ? (defer(() => this[EMITDATA](data)), true)\n                    : this[EMITDATA](data);\n        }\n        else if (ev === 'end') {\n            return this[EMITEND]();\n        }\n        else if (ev === 'close') {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED])\n                return false;\n            const ret = super.emit('close');\n            this.removeAllListeners('close');\n            return ret;\n        }\n        else if (ev === 'error') {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners('error').length\n                ? super.emit('error', data)\n                : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'resume') {\n            const ret = super.emit('resume');\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'finish' || ev === 'prefinish') {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]) {\n            if (p.dest.write(data) === false)\n                this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit('data', data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END])\n            return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC]\n            ? (defer(() => this[EMITEND2]()), true)\n            : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]) {\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED])\n                    super.emit('data', data);\n            }\n        }\n        for (const p of this[PIPES]) {\n            p.end();\n        }\n        const ret = super.emit('end');\n        this.removeAllListeners('end');\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */\n    async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0,\n        });\n        if (!this[OBJECTMODE])\n            buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on('data', c => {\n            buf.push(c);\n            if (!this[OBJECTMODE])\n                buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */\n    async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error('cannot concat in objectMode');\n        }\n        const buf = await this.collect();\n        return (this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength));\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */\n    async promise() {\n        return new Promise((resolve, reject) => {\n            this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n            this.on('error', er => reject(er));\n            this.on('end', () => resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */\n    [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async () => {\n            this.pause();\n            stopped = true;\n            return { value: undefined, done: true };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const res = this.read();\n            if (res !== null)\n                return Promise.resolve({ done: false, value: res });\n            if (this[EOF])\n                return stop();\n            let resolve;\n            let reject;\n            const onerr = (er) => {\n                this.off('data', ondata);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value) => {\n                this.off('error', onerr);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({ value, done: !!this[EOF] });\n            };\n            const onend = () => {\n                this.off('error', onerr);\n                this.off('data', ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({ done: true, value: undefined });\n            };\n            const ondestroy = () => onerr(new Error('stream destroyed'));\n            return new Promise((res, rej) => {\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once('error', onerr);\n                this.once('end', onend);\n                this.once('data', ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */\n    [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = () => {\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off('end', stop);\n            stopped = true;\n            return { done: true, value: undefined };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const value = this.read();\n            return value === null ? stop() : { done: false, value };\n        };\n        this.once('end', stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */\n    destroy(er) {\n        if (this[DESTROYED]) {\n            if (er)\n                this.emit('error', er);\n            else\n                this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === 'function' && !this[CLOSED])\n            wc.close();\n        if (er)\n            this.emit('error', er);\n        // if no error to emit, still reject pending promises\n        else\n            this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */\n    static get isStream() {\n        return exports.isStream;\n    }\n}\nexports.Minipass = Minipass;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaXBhc3MvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzQyxzQ0FBc0MsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzRCw4QkFBOEIsbUJBQU8sQ0FBQyxnREFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUF5QztBQUNqRCxRQUFRLHNDQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3QkFBd0I7QUFDM0U7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0Ryw4QkFBOEI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXJlY2lwZS8uL25vZGVfbW9kdWxlcy9taW5pcGFzcy9kaXN0L2NvbW1vbmpzL2luZGV4LmpzPzRhNjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1pbmlwYXNzID0gZXhwb3J0cy5pc1dyaXRhYmxlID0gZXhwb3J0cy5pc1JlYWRhYmxlID0gZXhwb3J0cy5pc1N0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHByb2MgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzc1xuICAgID8gcHJvY2Vzc1xuICAgIDoge1xuICAgICAgICBzdGRvdXQ6IG51bGwsXG4gICAgICAgIHN0ZGVycjogbnVsbCxcbiAgICB9O1xuY29uc3Qgbm9kZV9ldmVudHNfMSA9IHJlcXVpcmUoXCJub2RlOmV2ZW50c1wiKTtcbmNvbnN0IG5vZGVfc3RyZWFtXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6c3RyZWFtXCIpKTtcbmNvbnN0IG5vZGVfc3RyaW5nX2RlY29kZXJfMSA9IHJlcXVpcmUoXCJub2RlOnN0cmluZ19kZWNvZGVyXCIpO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSBNaW5pcGFzcyBzdHJlYW0sIE5vZGUgc3RyZWFtLCBvciBzb21ldGhpbmdcbiAqIGVsc2UgdGhhdCBNaW5pcGFzcyBjYW4gaW50ZXJhY3Qgd2l0aC5cbiAqL1xuY29uc3QgaXNTdHJlYW0gPSAocykgPT4gISFzICYmXG4gICAgdHlwZW9mIHMgPT09ICdvYmplY3QnICYmXG4gICAgKHMgaW5zdGFuY2VvZiBNaW5pcGFzcyB8fFxuICAgICAgICBzIGluc3RhbmNlb2Ygbm9kZV9zdHJlYW1fMS5kZWZhdWx0IHx8XG4gICAgICAgICgwLCBleHBvcnRzLmlzUmVhZGFibGUpKHMpIHx8XG4gICAgICAgICgwLCBleHBvcnRzLmlzV3JpdGFibGUpKHMpKTtcbmV4cG9ydHMuaXNTdHJlYW0gPSBpc1N0cmVhbTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQge0BsaW5rIE1pbmlwYXNzLlJlYWRhYmxlfVxuICovXG5jb25zdCBpc1JlYWRhYmxlID0gKHMpID0+ICEhcyAmJlxuICAgIHR5cGVvZiBzID09PSAnb2JqZWN0JyAmJlxuICAgIHMgaW5zdGFuY2VvZiBub2RlX2V2ZW50c18xLkV2ZW50RW1pdHRlciAmJlxuICAgIHR5cGVvZiBzLnBpcGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyBub2RlIGNvcmUgV3JpdGFibGUgc3RyZWFtcyBoYXZlIGEgcGlwZSgpIG1ldGhvZCwgYnV0IGl0IHRocm93c1xuICAgIHMucGlwZSAhPT0gbm9kZV9zdHJlYW1fMS5kZWZhdWx0LldyaXRhYmxlLnByb3RvdHlwZS5waXBlO1xuZXhwb3J0cy5pc1JlYWRhYmxlID0gaXNSZWFkYWJsZTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQge0BsaW5rIE1pbmlwYXNzLldyaXRhYmxlfVxuICovXG5jb25zdCBpc1dyaXRhYmxlID0gKHMpID0+ICEhcyAmJlxuICAgIHR5cGVvZiBzID09PSAnb2JqZWN0JyAmJlxuICAgIHMgaW5zdGFuY2VvZiBub2RlX2V2ZW50c18xLkV2ZW50RW1pdHRlciAmJlxuICAgIHR5cGVvZiBzLndyaXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHMuZW5kID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0cy5pc1dyaXRhYmxlID0gaXNXcml0YWJsZTtcbmNvbnN0IEVPRiA9IFN5bWJvbCgnRU9GJyk7XG5jb25zdCBNQVlCRV9FTUlUX0VORCA9IFN5bWJvbCgnbWF5YmVFbWl0RW5kJyk7XG5jb25zdCBFTUlUVEVEX0VORCA9IFN5bWJvbCgnZW1pdHRlZEVuZCcpO1xuY29uc3QgRU1JVFRJTkdfRU5EID0gU3ltYm9sKCdlbWl0dGluZ0VuZCcpO1xuY29uc3QgRU1JVFRFRF9FUlJPUiA9IFN5bWJvbCgnZW1pdHRlZEVycm9yJyk7XG5jb25zdCBDTE9TRUQgPSBTeW1ib2woJ2Nsb3NlZCcpO1xuY29uc3QgUkVBRCA9IFN5bWJvbCgncmVhZCcpO1xuY29uc3QgRkxVU0ggPSBTeW1ib2woJ2ZsdXNoJyk7XG5jb25zdCBGTFVTSENIVU5LID0gU3ltYm9sKCdmbHVzaENodW5rJyk7XG5jb25zdCBFTkNPRElORyA9IFN5bWJvbCgnZW5jb2RpbmcnKTtcbmNvbnN0IERFQ09ERVIgPSBTeW1ib2woJ2RlY29kZXInKTtcbmNvbnN0IEZMT1dJTkcgPSBTeW1ib2woJ2Zsb3dpbmcnKTtcbmNvbnN0IFBBVVNFRCA9IFN5bWJvbCgncGF1c2VkJyk7XG5jb25zdCBSRVNVTUUgPSBTeW1ib2woJ3Jlc3VtZScpO1xuY29uc3QgQlVGRkVSID0gU3ltYm9sKCdidWZmZXInKTtcbmNvbnN0IFBJUEVTID0gU3ltYm9sKCdwaXBlcycpO1xuY29uc3QgQlVGRkVSTEVOR1RIID0gU3ltYm9sKCdidWZmZXJMZW5ndGgnKTtcbmNvbnN0IEJVRkZFUlBVU0ggPSBTeW1ib2woJ2J1ZmZlclB1c2gnKTtcbmNvbnN0IEJVRkZFUlNISUZUID0gU3ltYm9sKCdidWZmZXJTaGlmdCcpO1xuY29uc3QgT0JKRUNUTU9ERSA9IFN5bWJvbCgnb2JqZWN0TW9kZScpO1xuLy8gaW50ZXJuYWwgZXZlbnQgd2hlbiBzdHJlYW0gaXMgZGVzdHJveWVkXG5jb25zdCBERVNUUk9ZRUQgPSBTeW1ib2woJ2Rlc3Ryb3llZCcpO1xuLy8gaW50ZXJuYWwgZXZlbnQgd2hlbiBzdHJlYW0gaGFzIGFuIGVycm9yXG5jb25zdCBFUlJPUiA9IFN5bWJvbCgnZXJyb3InKTtcbmNvbnN0IEVNSVREQVRBID0gU3ltYm9sKCdlbWl0RGF0YScpO1xuY29uc3QgRU1JVEVORCA9IFN5bWJvbCgnZW1pdEVuZCcpO1xuY29uc3QgRU1JVEVORDIgPSBTeW1ib2woJ2VtaXRFbmQyJyk7XG5jb25zdCBBU1lOQyA9IFN5bWJvbCgnYXN5bmMnKTtcbmNvbnN0IEFCT1JUID0gU3ltYm9sKCdhYm9ydCcpO1xuY29uc3QgQUJPUlRFRCA9IFN5bWJvbCgnYWJvcnRlZCcpO1xuY29uc3QgU0lHTkFMID0gU3ltYm9sKCdzaWduYWwnKTtcbmNvbnN0IERBVEFMSVNURU5FUlMgPSBTeW1ib2woJ2RhdGFMaXN0ZW5lcnMnKTtcbmNvbnN0IERJU0NBUkRFRCA9IFN5bWJvbCgnZGlzY2FyZGVkJyk7XG5jb25zdCBkZWZlciA9IChmbikgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbik7XG5jb25zdCBub2RlZmVyID0gKGZuKSA9PiBmbigpO1xuY29uc3QgaXNFbmRpc2ggPSAoZXYpID0+IGV2ID09PSAnZW5kJyB8fCBldiA9PT0gJ2ZpbmlzaCcgfHwgZXYgPT09ICdwcmVmaW5pc2gnO1xuY29uc3QgaXNBcnJheUJ1ZmZlckxpa2UgPSAoYikgPT4gYiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgKCEhYiAmJlxuICAgICAgICB0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgYi5jb25zdHJ1Y3RvciAmJlxuICAgICAgICBiLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicgJiZcbiAgICAgICAgYi5ieXRlTGVuZ3RoID49IDApO1xuY29uc3QgaXNBcnJheUJ1ZmZlclZpZXcgPSAoYikgPT4gIUJ1ZmZlci5pc0J1ZmZlcihiKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcoYik7XG4vKipcbiAqIEludGVybmFsIGNsYXNzIHJlcHJlc2VudGluZyBhIHBpcGUgdG8gYSBkZXN0aW5hdGlvbiBzdHJlYW0uXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFBpcGUge1xuICAgIHNyYztcbiAgICBkZXN0O1xuICAgIG9wdHM7XG4gICAgb25kcmFpbjtcbiAgICBjb25zdHJ1Y3RvcihzcmMsIGRlc3QsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuZGVzdCA9IGRlc3Q7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMub25kcmFpbiA9ICgpID0+IHNyY1tSRVNVTUVdKCk7XG4gICAgICAgIHRoaXMuZGVzdC5vbignZHJhaW4nLCB0aGlzLm9uZHJhaW4pO1xuICAgIH1cbiAgICB1bnBpcGUoKSB7XG4gICAgICAgIHRoaXMuZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCB0aGlzLm9uZHJhaW4pO1xuICAgIH1cbiAgICAvLyBvbmx5IGhlcmUgZm9yIHRoZSBwcm90b3R5cGVcbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBwcm94eUVycm9ycyhfZXIpIHsgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnVucGlwZSgpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmVuZClcbiAgICAgICAgICAgIHRoaXMuZGVzdC5lbmQoKTtcbiAgICB9XG59XG4vKipcbiAqIEludGVybmFsIGNsYXNzIHJlcHJlc2VudGluZyBhIHBpcGUgdG8gYSBkZXN0aW5hdGlvbiBzdHJlYW0gd2hlcmVcbiAqIGVycm9ycyBhcmUgcHJveGllZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUGlwZVByb3h5RXJyb3JzIGV4dGVuZHMgUGlwZSB7XG4gICAgdW5waXBlKCkge1xuICAgICAgICB0aGlzLnNyYy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCB0aGlzLnByb3h5RXJyb3JzKTtcbiAgICAgICAgc3VwZXIudW5waXBlKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNyYywgZGVzdCwgb3B0cykge1xuICAgICAgICBzdXBlcihzcmMsIGRlc3QsIG9wdHMpO1xuICAgICAgICB0aGlzLnByb3h5RXJyb3JzID0gZXIgPT4gZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgc3JjLm9uKCdlcnJvcicsIHRoaXMucHJveHlFcnJvcnMpO1xuICAgIH1cbn1cbmNvbnN0IGlzT2JqZWN0TW9kZU9wdGlvbnMgPSAobykgPT4gISFvLm9iamVjdE1vZGU7XG5jb25zdCBpc0VuY29kaW5nT3B0aW9ucyA9IChvKSA9PiAhby5vYmplY3RNb2RlICYmICEhby5lbmNvZGluZyAmJiBvLmVuY29kaW5nICE9PSAnYnVmZmVyJztcbi8qKlxuICogTWFpbiBleHBvcnQsIHRoZSBNaW5pcGFzcyBjbGFzc1xuICpcbiAqIGBSVHlwZWAgaXMgdGhlIHR5cGUgb2YgZGF0YSBlbWl0dGVkLCBkZWZhdWx0cyB0byBCdWZmZXJcbiAqXG4gKiBgV1R5cGVgIGlzIHRoZSB0eXBlIG9mIGRhdGEgdG8gYmUgd3JpdHRlbiwgaWYgUlR5cGUgaXMgYnVmZmVyIG9yIHN0cmluZyxcbiAqIHRoZW4gYW55IHtAbGluayBNaW5pcGFzcy5Db250aWd1b3VzRGF0YX0gaXMgYWxsb3dlZC5cbiAqXG4gKiBgRXZlbnRzYCBpcyB0aGUgc2V0IG9mIGV2ZW50IGhhbmRsZXIgc2lnbmF0dXJlcyB0aGF0IHRoaXMgb2JqZWN0XG4gKiB3aWxsIGVtaXQsIHNlZSB7QGxpbmsgTWluaXBhc3MuRXZlbnRzfVxuICovXG5jbGFzcyBNaW5pcGFzcyBleHRlbmRzIG5vZGVfZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBbRkxPV0lOR10gPSBmYWxzZTtcbiAgICBbUEFVU0VEXSA9IGZhbHNlO1xuICAgIFtQSVBFU10gPSBbXTtcbiAgICBbQlVGRkVSXSA9IFtdO1xuICAgIFtPQkpFQ1RNT0RFXTtcbiAgICBbRU5DT0RJTkddO1xuICAgIFtBU1lOQ107XG4gICAgW0RFQ09ERVJdO1xuICAgIFtFT0ZdID0gZmFsc2U7XG4gICAgW0VNSVRURURfRU5EXSA9IGZhbHNlO1xuICAgIFtFTUlUVElOR19FTkRdID0gZmFsc2U7XG4gICAgW0NMT1NFRF0gPSBmYWxzZTtcbiAgICBbRU1JVFRFRF9FUlJPUl0gPSBudWxsO1xuICAgIFtCVUZGRVJMRU5HVEhdID0gMDtcbiAgICBbREVTVFJPWUVEXSA9IGZhbHNlO1xuICAgIFtTSUdOQUxdO1xuICAgIFtBQk9SVEVEXSA9IGZhbHNlO1xuICAgIFtEQVRBTElTVEVORVJTXSA9IDA7XG4gICAgW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gY2FuIGJlIHdyaXR0ZW5cbiAgICAgKi9cbiAgICB3cml0YWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGNhbiBiZSByZWFkXG4gICAgICovXG4gICAgcmVhZGFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIElmIGBSVHlwZWAgaXMgQnVmZmVyLCB0aGVuIG9wdGlvbnMgZG8gbm90IG5lZWQgdG8gYmUgcHJvdmlkZWQuXG4gICAgICogT3RoZXJ3aXNlLCBhbiBvcHRpb25zIG9iamVjdCBtdXN0IGJlIHByb3ZpZGVkIHRvIHNwZWNpZnkgZWl0aGVyXG4gICAgICoge0BsaW5rIE1pbmlwYXNzLlNoYXJlZE9wdGlvbnMub2JqZWN0TW9kZX0gb3JcbiAgICAgKiB7QGxpbmsgTWluaXBhc3MuU2hhcmVkT3B0aW9ucy5lbmNvZGluZ30sIGFzIGFwcHJvcHJpYXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IChhcmdzWzBdIHx8XG4gICAgICAgICAgICB7fSk7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChvcHRpb25zLm9iamVjdE1vZGUgJiYgdHlwZW9mIG9wdGlvbnMuZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGluZyBhbmQgb2JqZWN0TW9kZSBtYXkgbm90IGJlIHVzZWQgdG9nZXRoZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3RNb2RlT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFbmNvZGluZ09wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXNbRU5DT0RJTkddID0gb3B0aW9ucy5lbmNvZGluZztcbiAgICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbRU5DT0RJTkddID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW0FTWU5DXSA9ICEhb3B0aW9ucy5hc3luYztcbiAgICAgICAgdGhpc1tERUNPREVSXSA9IHRoaXNbRU5DT0RJTkddXG4gICAgICAgICAgICA/IG5ldyBub2RlX3N0cmluZ19kZWNvZGVyXzEuU3RyaW5nRGVjb2Rlcih0aGlzW0VOQ09ESU5HXSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgLy9AdHMtaWdub3JlIC0gcHJpdmF0ZSBvcHRpb24gZm9yIGRlYnVnZ2luZyBhbmQgdGVzdGluZ1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnRXhwb3NlQnVmZmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2J1ZmZlcicsIHsgZ2V0OiAoKSA9PiB0aGlzW0JVRkZFUl0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9AdHMtaWdub3JlIC0gcHJpdmF0ZSBvcHRpb24gZm9yIGRlYnVnZ2luZyBhbmQgdGVzdGluZ1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnRXhwb3NlUGlwZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGlwZXMnLCB7IGdldDogKCkgPT4gdGhpc1tQSVBFU10gfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaWduYWwgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgIHRoaXNbU0lHTkFMXSA9IHNpZ25hbDtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbQUJPUlRdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzW0FCT1JUXSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYW1vdW50IG9mIGRhdGEgc3RvcmVkIGluIHRoZSBidWZmZXIgd2FpdGluZyB0byBiZSByZWFkLlxuICAgICAqXG4gICAgICogRm9yIEJ1ZmZlciBzdHJpbmdzLCB0aGlzIHdpbGwgYmUgdGhlIHRvdGFsIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEZvciBzdHJpbmcgZW5jb2Rpbmcgc3RyZWFtcywgdGhpcyB3aWxsIGJlIHRoZSBzdHJpbmcgY2hhcmFjdGVyIGxlbmd0aCxcbiAgICAgKiBhY2NvcmRpbmcgdG8gSmF2YVNjcmlwdCdzIGBzdHJpbmcubGVuZ3RoYCBsb2dpYy5cbiAgICAgKiBGb3Igb2JqZWN0TW9kZSBzdHJlYW1zLCB0aGlzIGlzIGEgY291bnQgb2YgdGhlIGl0ZW1zIHdhaXRpbmcgdG8gYmVcbiAgICAgKiBlbWl0dGVkLlxuICAgICAqL1xuICAgIGdldCBidWZmZXJMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0JVRkZFUkxFTkdUSF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgQnVmZmVyRW5jb2RpbmdgIGN1cnJlbnRseSBpbiB1c2UsIG9yIGBudWxsYFxuICAgICAqL1xuICAgIGdldCBlbmNvZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbRU5DT0RJTkddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCAtIFRoaXMgaXMgYSByZWFkIG9ubHkgcHJvcGVydHlcbiAgICAgKi9cbiAgICBzZXQgZW5jb2RpbmcoX2VuYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIG11c3QgYmUgc2V0IGF0IGluc3RhbnRpYXRpb24gdGltZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCAtIEVuY29kaW5nIG1heSBvbmx5IGJlIHNldCBhdCBpbnN0YW50aWF0aW9uIHRpbWVcbiAgICAgKi9cbiAgICBzZXRFbmNvZGluZyhfZW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb2RpbmcgbXVzdCBiZSBzZXQgYXQgaW5zdGFudGlhdGlvbiB0aW1lJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhpcyBpcyBhbiBvYmplY3RNb2RlIHN0cmVhbVxuICAgICAqL1xuICAgIGdldCBvYmplY3RNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tPQkpFQ1RNT0RFXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgLSBUaGlzIGlzIGEgcmVhZC1vbmx5IHByb3BlcnR5XG4gICAgICovXG4gICAgc2V0IG9iamVjdE1vZGUoX29tKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb2JqZWN0TW9kZSBtdXN0IGJlIHNldCBhdCBpbnN0YW50aWF0aW9uIHRpbWUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGlzIGlzIGFuIGFzeW5jIHN0cmVhbVxuICAgICAqL1xuICAgIGdldCBbJ2FzeW5jJ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0FTWU5DXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gbWFrZSB0aGlzIHN0cmVhbSBhc3luYy5cbiAgICAgKlxuICAgICAqIE9uY2Ugc2V0LCBpdCBjYW5ub3QgYmUgdW5zZXQsIGFzIHRoaXMgd291bGQgcG90ZW50aWFsbHkgY2F1c2UgaW5jb3JyZWN0XG4gICAgICogYmVoYXZpb3IuICBJZSwgYSBzeW5jIHN0cmVhbSBjYW4gYmUgbWFkZSBhc3luYywgYnV0IGFuIGFzeW5jIHN0cmVhbVxuICAgICAqIGNhbm5vdCBiZSBzYWZlbHkgbWFkZSBzeW5jLlxuICAgICAqL1xuICAgIHNldCBbJ2FzeW5jJ10oYSkge1xuICAgICAgICB0aGlzW0FTWU5DXSA9IHRoaXNbQVNZTkNdIHx8ICEhYTtcbiAgICB9XG4gICAgLy8gZHJvcCBldmVyeXRoaW5nIGFuZCBnZXQgb3V0IG9mIHRoZSBmbG93IGNvbXBsZXRlbHlcbiAgICBbQUJPUlRdKCkge1xuICAgICAgICB0aGlzW0FCT1JURURdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdhYm9ydCcsIHRoaXNbU0lHTkFMXT8ucmVhc29uKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KHRoaXNbU0lHTkFMXT8ucmVhc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgc3RyZWFtIGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICovXG4gICAgZ2V0IGFib3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0FCT1JURURdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOby1vcCBzZXR0ZXIuIFN0cmVhbSBhYm9ydGVkIHN0YXR1cyBpcyBzZXQgdmlhIHRoZSBBYm9ydFNpZ25hbCBwcm92aWRlZFxuICAgICAqIGluIHRoZSBjb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgICAqL1xuICAgIHNldCBhYm9ydGVkKF8pIHsgfVxuICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgaWYgKHRoaXNbQUJPUlRFRF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIHdyaXRlIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnKSwgeyBjb2RlOiAnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVuY29kaW5nKVxuICAgICAgICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICAgIGNvbnN0IGZuID0gdGhpc1tBU1lOQ10gPyBkZWZlciA6IG5vZGVmZXI7XG4gICAgICAgIC8vIGNvbnZlcnQgYXJyYXkgYnVmZmVycyBhbmQgdHlwZWQgYXJyYXkgdmlld3MgaW50byBidWZmZXJzXG4gICAgICAgIC8vIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSwgd2UgbWF5IHdhbnQgdG8gZG8gdGhlIG9wcG9zaXRlIVxuICAgICAgICAvLyBsZWF2ZSBzdHJpbmdzIGFuZCBidWZmZXJzIGFzLWlzXG4gICAgICAgIC8vIGFueXRoaW5nIGlzIG9ubHkgYWxsb3dlZCBpZiBpbiBvYmplY3QgbW9kZSwgc28gdGhyb3dcbiAgICAgICAgaWYgKCF0aGlzW09CSkVDVE1PREVdICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlIC0gc2luZnVsIHVuc2FmZSB0eXBlIGNoYW5naW5nXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUJ1ZmZlckxpa2UoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlIC0gc2luZnVsIHVuc2FmZSB0eXBlIGNoYW5naW5nXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tY29udGlndW91cyBkYXRhIHdyaXR0ZW4gdG8gbm9uLW9iamVjdE1vZGUgc3RyZWFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIG9iamVjdCBtb2RlIHVwIGZyb250LCBzaW5jZSBpdCdzIHNpbXBsZXJcbiAgICAgICAgLy8gdGhpcyB5aWVsZHMgYmV0dGVyIHBlcmZvcm1hbmNlLCBmZXdlciBjaGVja3MgbGF0ZXIuXG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAgICAgICAvLyBtYXliZSBpbXBvc3NpYmxlP1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhpc1tGTFVTSF0odHJ1ZSk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10pXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSUFVTSF0oY2h1bmspO1xuICAgICAgICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICAgICAgZm4oY2IpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgY2h1bmsgaXMgYSBidWZmZXIgb3Igc3RyaW5nXG4gICAgICAgIC8vIGRvbid0IGJ1ZmZlciBpdCB1cCBvciBzZW5kIGl0IHRvIHRoZSBkZWNvZGVyXG4gICAgICAgIGlmICghY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKTtcbiAgICAgICAgICAgIGlmIChjYilcbiAgICAgICAgICAgICAgICBmbihjYik7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmYXN0LXBhdGggd3JpdGluZyBzdHJpbmdzIG9mIHNhbWUgZW5jb2RpbmcgdG8gYSBzdHJlYW0gd2l0aFxuICAgICAgICAvLyBhbiBlbXB0eSBidWZmZXIsIHNraXBwaW5nIHRoZSBidWZmZXIvZGVjb2RlciBkYW5jZVxuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgc3RyaW5nIGFscmVhZHkgcmVhZHkgZm9yIHVzIHRvIHVzZVxuICAgICAgICAgICAgIShlbmNvZGluZyA9PT0gdGhpc1tFTkNPRElOR10gJiYgIXRoaXNbREVDT0RFUl0/Lmxhc3ROZWVkKSkge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlIC0gc2luZnVsIHVuc2FmZSB0eXBlIGNoYW5nZVxuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHRoaXNbRU5DT0RJTkddKSB7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmUgLSBzaW5mdWwgdW5zYWZlIHR5cGUgY2hhbmdlXG4gICAgICAgICAgICBjaHVuayA9IHRoaXNbREVDT0RFUl0ud3JpdGUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGZsdXNoaW5nIENBTiBwb3RlbnRpYWxseSBzd2l0Y2ggdXMgaW50byBub3QtZmxvd2luZyBtb2RlXG4gICAgICAgIGlmICh0aGlzW0ZMT1dJTkddICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgIHRoaXNbRkxVU0hdKHRydWUpO1xuICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSlcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJQVVNIXShjaHVuayk7XG4gICAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICAgIGlmIChjYilcbiAgICAgICAgICAgIGZuKGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvdy1sZXZlbCBleHBsaWNpdCByZWFkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEluIG9iamVjdE1vZGUsIHRoZSBhcmd1bWVudCBpcyBpZ25vcmVkLCBhbmQgb25lIGl0ZW0gaXMgcmV0dXJuZWQgaWZcbiAgICAgKiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBgbmAgaXMgdGhlIG51bWJlciBvZiBieXRlcyAob3IgaW4gdGhlIGNhc2Ugb2YgZW5jb2Rpbmcgc3RyZWFtcyxcbiAgICAgKiBjaGFyYWN0ZXJzKSB0byBjb25zdW1lLiBJZiBgbmAgaXMgbm90IHByb3ZpZGVkLCB0aGVuIHRoZSBlbnRpcmUgYnVmZmVyXG4gICAgICogaXMgcmV0dXJuZWQsIG9yIGBudWxsYCBpcyByZXR1cm5lZCBpZiBubyBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIElmIGBuYCBpcyBncmVhdGVyIHRoYXQgdGhlIGFtb3VudCBvZiBkYXRhIGluIHRoZSBpbnRlcm5hbCBidWZmZXIsXG4gICAgICogdGhlbiBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgcmVhZChuKSB7XG4gICAgICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gPT09IDAgfHxcbiAgICAgICAgICAgIG4gPT09IDAgfHxcbiAgICAgICAgICAgIChuICYmIG4gPiB0aGlzW0JVRkZFUkxFTkdUSF0pKSB7XG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICBuID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXNbQlVGRkVSXS5sZW5ndGggPiAxICYmICF0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAgICAgICAvLyBub3Qgb2JqZWN0IG1vZGUsIHNvIGlmIHdlIGhhdmUgYW4gZW5jb2RpbmcsIHRoZW4gUlR5cGUgaXMgc3RyaW5nXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIG11c3QgYmUgQnVmZmVyXG4gICAgICAgICAgICB0aGlzW0JVRkZFUl0gPSBbXG4gICAgICAgICAgICAgICAgKHRoaXNbRU5DT0RJTkddXG4gICAgICAgICAgICAgICAgICAgID8gdGhpc1tCVUZGRVJdLmpvaW4oJycpXG4gICAgICAgICAgICAgICAgICAgIDogQnVmZmVyLmNvbmNhdCh0aGlzW0JVRkZFUl0sIHRoaXNbQlVGRkVSTEVOR1RIXSkpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzW1JFQURdKG4gfHwgbnVsbCwgdGhpc1tCVUZGRVJdWzBdKTtcbiAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgW1JFQURdKG4sIGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJTSElGVF0oKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjID0gY2h1bms7XG4gICAgICAgICAgICBpZiAobiA9PT0gYy5sZW5ndGggfHwgbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUlNISUZUXSgpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdWzBdID0gYy5zbGljZShuKTtcbiAgICAgICAgICAgICAgICBjaHVuayA9IGMuc2xpY2UoMCwgbik7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl1bMF0gPSBjLnN1YmFycmF5KG4pO1xuICAgICAgICAgICAgICAgIGNodW5rID0gYy5zdWJhcnJheSgwLCBuKTtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIGlmICghdGhpc1tCVUZGRVJdLmxlbmd0aCAmJiAhdGhpc1tFT0ZdKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGVuZChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gY2h1bms7XG4gICAgICAgICAgICBjaHVuayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGlmIChjYilcbiAgICAgICAgICAgIHRoaXMub25jZSgnZW5kJywgY2IpO1xuICAgICAgICB0aGlzW0VPRl0gPSB0cnVlO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIGlmIHdlIGhhdmVuJ3Qgd3JpdHRlbiBhbnl0aGluZywgdGhlbiBnbyBhaGVhZCBhbmQgZW1pdCxcbiAgICAgICAgLy8gZXZlbiBpZiB3ZSdyZSBub3QgcmVhZGluZy5cbiAgICAgICAgLy8gd2UnbGwgcmUtZW1pdCBpZiBhIG5ldyAnZW5kJyBsaXN0ZW5lciBpcyBhZGRlZCBhbnl3YXkuXG4gICAgICAgIC8vIFRoaXMgbWFrZXMgTVAgbW9yZSBzdWl0YWJsZSB0byB3cml0ZS1vbmx5IHVzZSBjYXNlcy5cbiAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10gfHwgIXRoaXNbUEFVU0VEXSlcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBkb24ndCBsZXQgdGhlIGludGVybmFsIHJlc3VtZSBiZSBvdmVyd3JpdHRlblxuICAgIFtSRVNVTUVdKCkge1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXNbREFUQUxJU1RFTkVSU10gJiYgIXRoaXNbUElQRVNdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpc1tESVNDQVJERURdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW1BBVVNFRF0gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tGTE9XSU5HXSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgncmVzdW1lJyk7XG4gICAgICAgIGlmICh0aGlzW0JVRkZFUl0ubGVuZ3RoKVxuICAgICAgICAgICAgdGhpc1tGTFVTSF0oKTtcbiAgICAgICAgZWxzZSBpZiAodGhpc1tFT0ZdKVxuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN1bWUgdGhlIHN0cmVhbSBpZiBpdCBpcyBjdXJyZW50bHkgaW4gYSBwYXVzZWQgc3RhdGVcbiAgICAgKlxuICAgICAqIElmIGNhbGxlZCB3aGVuIHRoZXJlIGFyZSBubyBwaXBlIGRlc3RpbmF0aW9ucyBvciBgZGF0YWAgZXZlbnQgbGlzdGVuZXJzLFxuICAgICAqIHRoaXMgd2lsbCBwbGFjZSB0aGUgc3RyZWFtIGluIGEgXCJkaXNjYXJkZWRcIiBzdGF0ZSwgd2hlcmUgYWxsIGRhdGEgd2lsbFxuICAgICAqIGJlIHRocm93biBhd2F5LiBUaGUgZGlzY2FyZGVkIHN0YXRlIGlzIHJlbW92ZWQgaWYgYSBwaXBlIGRlc3RpbmF0aW9uIG9yXG4gICAgICogZGF0YSBoYW5kbGVyIGlzIGFkZGVkLCBpZiBwYXVzZSgpIGlzIGNhbGxlZCwgb3IgaWYgYW55IHN5bmNocm9ub3VzIG9yXG4gICAgICogYXN5bmNocm9ub3VzIGl0ZXJhdGlvbiBpcyBzdGFydGVkLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbUkVTVU1FXSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgc3RyZWFtXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tQQVVTRURdID0gdHJ1ZTtcbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHN0cmVhbSBoYXMgYmVlbiBmb3JjaWJseSBkZXN0cm95ZWRcbiAgICAgKi9cbiAgICBnZXQgZGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tERVNUUk9ZRURdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGluIGEgZmxvd2luZyBzdGF0ZSwgbWVhbmluZyB0aGF0XG4gICAgICogYW55IHdyaXRlcyB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQuXG4gICAgICovXG4gICAgZ2V0IGZsb3dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGluIGEgcGF1c2VkIHN0YXRlXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbUEFVU0VEXTtcbiAgICB9XG4gICAgW0JVRkZFUlBVU0hdKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdICs9IDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHRoaXNbQlVGRkVSXS5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgW0JVRkZFUlNISUZUXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IHRoaXNbQlVGRkVSXVswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzW0JVRkZFUl0uc2hpZnQoKTtcbiAgICB9XG4gICAgW0ZMVVNIXShub0RyYWluID0gZmFsc2UpIHtcbiAgICAgICAgZG8geyB9IHdoaWxlICh0aGlzW0ZMVVNIQ0hVTktdKHRoaXNbQlVGRkVSU0hJRlRdKCkpICYmXG4gICAgICAgICAgICB0aGlzW0JVRkZFUl0ubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFub0RyYWluICYmICF0aGlzW0JVRkZFUl0ubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgfVxuICAgIFtGTFVTSENIVU5LXShjaHVuaykge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQaXBlIGFsbCBkYXRhIGVtaXR0ZWQgYnkgdGhpcyBzdHJlYW0gaW50byB0aGUgZGVzdGluYXRpb24gcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBUcmlnZ2VycyB0aGUgZmxvdyBvZiBkYXRhLlxuICAgICAqL1xuICAgIHBpcGUoZGVzdCwgb3B0cykge1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBlbmRlZCA9IHRoaXNbRU1JVFRFRF9FTkRdO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgaWYgKGRlc3QgPT09IHByb2Muc3Rkb3V0IHx8IGRlc3QgPT09IHByb2Muc3RkZXJyKVxuICAgICAgICAgICAgb3B0cy5lbmQgPSBmYWxzZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3B0cy5lbmQgPSBvcHRzLmVuZCAhPT0gZmFsc2U7XG4gICAgICAgIG9wdHMucHJveHlFcnJvcnMgPSAhIW9wdHMucHJveHlFcnJvcnM7XG4gICAgICAgIC8vIHBpcGluZyBhbiBlbmRlZCBzdHJlYW0gZW5kcyBpbW1lZGlhdGVseVxuICAgICAgICBpZiAoZW5kZWQpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmVuZClcbiAgICAgICAgICAgICAgICBkZXN0LmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gXCJhc1wiIGhlcmUganVzdCBpZ25vcmVzIHRoZSBXVHlwZSwgd2hpY2ggcGlwZXMgZG9uJ3QgY2FyZSBhYm91dCxcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkncmUgb25seSBjb25zdW1pbmcgZnJvbSB1cywgYW5kIHdyaXRpbmcgdG8gdGhlIGRlc3RcbiAgICAgICAgICAgIHRoaXNbUElQRVNdLnB1c2goIW9wdHMucHJveHlFcnJvcnNcbiAgICAgICAgICAgICAgICA/IG5ldyBQaXBlKHRoaXMsIGRlc3QsIG9wdHMpXG4gICAgICAgICAgICAgICAgOiBuZXcgUGlwZVByb3h5RXJyb3JzKHRoaXMsIGRlc3QsIG9wdHMpKTtcbiAgICAgICAgICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgICAgICAgICAgICBkZWZlcigoKSA9PiB0aGlzW1JFU1VNRV0oKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpc1tSRVNVTUVdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bGx5IHVuaG9vayBhIHBpcGVkIGRlc3RpbmF0aW9uIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBkZXN0aW5hdGlvbiBzdHJlYW0gd2FzIHRoZSBvbmx5IGNvbnN1bWVyIG9mIHRoaXMgc3RyZWFtIChpZSxcbiAgICAgKiB0aGVyZSBhcmUgbm8gb3RoZXIgcGlwZWQgZGVzdGluYXRpb25zIG9yIGAnZGF0YSdgIGV2ZW50IGxpc3RlbmVycylcbiAgICAgKiB0aGVuIHRoZSBmbG93IG9mIGRhdGEgd2lsbCBzdG9wIHVudGlsIHRoZXJlIGlzIGFub3RoZXIgY29uc3VtZXIgb3JcbiAgICAgKiB7QGxpbmsgTWluaXBhc3MjcmVzdW1lfSBpcyBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKi9cbiAgICB1bnBpcGUoZGVzdCkge1xuICAgICAgICBjb25zdCBwID0gdGhpc1tQSVBFU10uZmluZChwID0+IHAuZGVzdCA9PT0gZGVzdCk7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tQSVBFU10ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10gJiYgdGhpc1tEQVRBTElTVEVORVJTXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNbUElQRVNdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpc1tQSVBFU10uc3BsaWNlKHRoaXNbUElQRVNdLmluZGV4T2YocCksIDEpO1xuICAgICAgICAgICAgcC51bnBpcGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIE1pbmlwYXNzI29ufVxuICAgICAqL1xuICAgIGFkZExpc3RlbmVyKGV2LCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGlkZW50aWNhbCB0byBgRXZlbnRFbWl0dGVyLm9uYCwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAgICogYmVoYXZpb3IgZGlmZmVyZW5jZXMgdG8gcHJldmVudCBkYXRhIGxvc3MgYW5kIHVubmVjZXNzYXJ5IGhhbmdzOlxuICAgICAqXG4gICAgICogLSBBZGRpbmcgYSAnZGF0YScgZXZlbnQgaGFuZGxlciB3aWxsIHRyaWdnZXIgdGhlIGZsb3cgb2YgZGF0YVxuICAgICAqXG4gICAgICogLSBBZGRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGhhbmRsZXIgd2hlbiB0aGVyZSBpcyBkYXRhIHdhaXRpbmcgdG8gYmUgcmVhZFxuICAgICAqICAgd2lsbCBjYXVzZSAncmVhZGFibGUnIHRvIGJlIGVtaXR0ZWQgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiAtIEFkZGluZyBhbiAnZW5kaXNoJyBldmVudCBoYW5kbGVyICgnZW5kJywgJ2ZpbmlzaCcsIGV0Yy4pIHdoaWNoIGhhc1xuICAgICAqICAgYWxyZWFkeSBwYXNzZWQgd2lsbCBjYXVzZSB0aGUgZXZlbnQgdG8gYmUgZW1pdHRlZCBpbW1lZGlhdGVseSBhbmQgYWxsXG4gICAgICogICBoYW5kbGVycyByZW1vdmVkLlxuICAgICAqXG4gICAgICogLSBBZGRpbmcgYW4gJ2Vycm9yJyBldmVudCBoYW5kbGVyIGFmdGVyIGFuIGVycm9yIGhhcyBiZWVuIGVtaXR0ZWQgd2lsbFxuICAgICAqICAgY2F1c2UgdGhlIGV2ZW50IHRvIGJlIHJlLWVtaXR0ZWQgaW1tZWRpYXRlbHkgd2l0aCB0aGUgZXJyb3IgcHJldmlvdXNseVxuICAgICAqICAgcmFpc2VkLlxuICAgICAqL1xuICAgIG9uKGV2LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLm9uKGV2LCBoYW5kbGVyKTtcbiAgICAgICAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tEQVRBTElTVEVORVJTXSsrO1xuICAgICAgICAgICAgaWYgKCF0aGlzW1BJUEVTXS5sZW5ndGggJiYgIXRoaXNbRkxPV0lOR10pIHtcbiAgICAgICAgICAgICAgICB0aGlzW1JFU1VNRV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApIHtcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFbmRpc2goZXYpICYmIHRoaXNbRU1JVFRFRF9FTkRdKSB7XG4gICAgICAgICAgICBzdXBlci5lbWl0KGV2KTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2Vycm9yJyAmJiB0aGlzW0VNSVRURURfRVJST1JdKSB7XG4gICAgICAgICAgICBjb25zdCBoID0gaGFuZGxlcjtcbiAgICAgICAgICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgICAgICAgICAgICBkZWZlcigoKSA9PiBoLmNhbGwodGhpcywgdGhpc1tFTUlUVEVEX0VSUk9SXSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGguY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIE1pbmlwYXNzI29mZn1cbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcihldiwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXYsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3N0bHkgaWRlbnRpY2FsIHRvIGBFdmVudEVtaXR0ZXIub2ZmYFxuICAgICAqXG4gICAgICogSWYgYSAnZGF0YScgZXZlbnQgaGFuZGxlciBpcyByZW1vdmVkLCBhbmQgaXQgd2FzIHRoZSBsYXN0IGNvbnN1bWVyXG4gICAgICogKGllLCB0aGVyZSBhcmUgbm8gcGlwZSBkZXN0aW5hdGlvbnMgb3Igb3RoZXIgJ2RhdGEnIGV2ZW50IGxpc3RlbmVycyksXG4gICAgICogdGhlbiB0aGUgZmxvdyBvZiBkYXRhIHdpbGwgc3RvcCB1bnRpbCB0aGVyZSBpcyBhbm90aGVyIGNvbnN1bWVyIG9yXG4gICAgICoge0BsaW5rIE1pbmlwYXNzI3Jlc3VtZX0gaXMgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICovXG4gICAgb2ZmKGV2LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLm9mZihldiwgaGFuZGxlcik7XG4gICAgICAgIC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGxpc3RlbmVycywgYW5kIG5vdyB3ZSBkb24ndCwgYW5kIHdlIGRvbid0XG4gICAgICAgIC8vIGhhdmUgYW55IHBpcGVzLCB0aGVuIHN0b3AgdGhlIGZsb3csIHVubGVzcyBpdCdzIGJlZW4gZXhwbGljaXRseVxuICAgICAgICAvLyBwdXQgaW4gYSBkaXNjYXJkZWQgZmxvd2luZyBzdGF0ZSB2aWEgc3RyZWFtLnJlc3VtZSgpLlxuICAgICAgICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgdGhpc1tEQVRBTElTVEVORVJTXSA9IHRoaXMubGlzdGVuZXJzKCdkYXRhJykubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXNbREFUQUxJU1RFTkVSU10gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAhdGhpc1tESVNDQVJERURdICYmXG4gICAgICAgICAgICAgICAgIXRoaXNbUElQRVNdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3N0bHkgaWRlbnRpY2FsIHRvIGBFdmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzYFxuICAgICAqXG4gICAgICogSWYgYWxsICdkYXRhJyBldmVudCBoYW5kbGVycyBhcmUgcmVtb3ZlZCwgYW5kIHRoZXkgd2VyZSB0aGUgbGFzdCBjb25zdW1lclxuICAgICAqIChpZSwgdGhlcmUgYXJlIG5vIHBpcGUgZGVzdGluYXRpb25zKSwgdGhlbiB0aGUgZmxvdyBvZiBkYXRhIHdpbGwgc3RvcFxuICAgICAqIHVudGlsIHRoZXJlIGlzIGFub3RoZXIgY29uc3VtZXIgb3Ige0BsaW5rIE1pbmlwYXNzI3Jlc3VtZX0gaXMgZXhwbGljaXRseVxuICAgICAqIGNhbGxlZC5cbiAgICAgKi9cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXYpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KTtcbiAgICAgICAgaWYgKGV2ID09PSAnZGF0YScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpc1tEQVRBTElTVEVORVJTXSA9IDA7XG4gICAgICAgICAgICBpZiAoIXRoaXNbRElTQ0FSREVEXSAmJiAhdGhpc1tQSVBFU10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlICdlbmQnIGV2ZW50IGhhcyBiZWVuIGVtaXR0ZWRcbiAgICAgKi9cbiAgICBnZXQgZW1pdHRlZEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbRU1JVFRFRF9FTkRdO1xuICAgIH1cbiAgICBbTUFZQkVfRU1JVF9FTkRdKCkge1xuICAgICAgICBpZiAoIXRoaXNbRU1JVFRJTkdfRU5EXSAmJlxuICAgICAgICAgICAgIXRoaXNbRU1JVFRFRF9FTkRdICYmXG4gICAgICAgICAgICAhdGhpc1tERVNUUk9ZRURdICYmXG4gICAgICAgICAgICB0aGlzW0JVRkZFUl0ubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICB0aGlzW0VPRl0pIHtcbiAgICAgICAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgICBpZiAodGhpc1tDTE9TRURdKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3RseSBpZGVudGljYWwgdG8gYEV2ZW50RW1pdHRlci5lbWl0YCwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAgICogYmVoYXZpb3IgZGlmZmVyZW5jZXMgdG8gcHJldmVudCBkYXRhIGxvc3MgYW5kIHVubmVjZXNzYXJ5IGhhbmdzOlxuICAgICAqXG4gICAgICogSWYgdGhlIHN0cmVhbSBoYXMgYmVlbiBkZXN0cm95ZWQsIGFuZCB0aGUgZXZlbnQgaXMgc29tZXRoaW5nIG90aGVyXG4gICAgICogdGhhbiAnY2xvc2UnIG9yICdlcnJvcicsIHRoZW4gYGZhbHNlYCBpcyByZXR1cm5lZCBhbmQgbm8gaGFuZGxlcnNcbiAgICAgKiBhcmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzICdlbmQnLCBhbmQgaGFzIGFscmVhZHkgYmVlbiBlbWl0dGVkLCB0aGVuIHRoZSBldmVudFxuICAgICAqIGlzIGlnbm9yZWQuIElmIHRoZSBzdHJlYW0gaXMgaW4gYSBwYXVzZWQgb3Igbm9uLWZsb3dpbmcgc3RhdGUsIHRoZW5cbiAgICAgKiB0aGUgZXZlbnQgd2lsbCBiZSBkZWZlcnJlZCB1bnRpbCBkYXRhIGZsb3cgcmVzdW1lcy4gSWYgdGhlIHN0cmVhbSBpc1xuICAgICAqIGFzeW5jLCB0aGVuIGhhbmRsZXJzIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSBuZXh0IHRpY2sgcmF0aGVyIHRoYW5cbiAgICAgKiBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBldmVudCBpcyAnY2xvc2UnLCBhbmQgJ2VuZCcgaGFzIG5vdCB5ZXQgYmVlbiBlbWl0dGVkLCB0aGVuXG4gICAgICogdGhlIGV2ZW50IHdpbGwgYmUgZGVmZXJyZWQgdW50aWwgYWZ0ZXIgJ2VuZCcgaXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBldmVudCBpcyAnZXJyb3InLCBhbmQgYW4gQWJvcnRTaWduYWwgd2FzIHByb3ZpZGVkIGZvciB0aGUgc3RyZWFtLFxuICAgICAqIGFuZCB0aGVyZSBhcmUgbm8gbGlzdGVuZXJzLCB0aGVuIHRoZSBldmVudCBpcyBpZ25vcmVkLCBtYXRjaGluZyB0aGVcbiAgICAgKiBiZWhhdmlvciBvZiBub2RlIGNvcmUgc3RyZWFtcyBpbiB0aGUgcHJlc2Vuc2Ugb2YgYW4gQWJvcnRTaWduYWwuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgJ2ZpbmlzaCcgb3IgJ3ByZWZpbmlzaCcsIHRoZW4gYWxsIGxpc3RlbmVycyB3aWxsIGJlXG4gICAgICogcmVtb3ZlZCBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnQsIHRvIHByZXZlbnQgZG91YmxlLWZpcmluZy5cbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhcmdzWzBdO1xuICAgICAgICAvLyBlcnJvciBhbmQgY2xvc2UgYXJlIG9ubHkgZXZlbnRzIGFsbG93ZWQgYWZ0ZXIgY2FsbGluZyBkZXN0cm95KClcbiAgICAgICAgaWYgKGV2ICE9PSAnZXJyb3InICYmXG4gICAgICAgICAgICBldiAhPT0gJ2Nsb3NlJyAmJlxuICAgICAgICAgICAgZXYgIT09IERFU1RST1lFRCAmJlxuICAgICAgICAgICAgdGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzW09CSkVDVE1PREVdICYmICFkYXRhXG4gICAgICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpc1tBU1lOQ11cbiAgICAgICAgICAgICAgICAgICAgPyAoZGVmZXIoKCkgPT4gdGhpc1tFTUlUREFUQV0oZGF0YSkpLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXNbRU1JVERBVEFdKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZW5kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbRU1JVEVORF0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2Nsb3NlJykge1xuICAgICAgICAgICAgdGhpc1tDTE9TRURdID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGRvbid0IGVtaXQgY2xvc2UgYmVmb3JlICdlbmQnIGFuZCAnZmluaXNoJ1xuICAgICAgICAgICAgaWYgKCF0aGlzW0VNSVRURURfRU5EXSAmJiAhdGhpc1tERVNUUk9ZRURdKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHRoaXNbRU1JVFRFRF9FUlJPUl0gPSBkYXRhO1xuICAgICAgICAgICAgc3VwZXIuZW1pdChFUlJPUiwgZGF0YSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSAhdGhpc1tTSUdOQUxdIHx8IHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gc3VwZXIuZW1pdCgnZXJyb3InLCBkYXRhKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ3Jlc3VtZScpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ3Jlc3VtZScpO1xuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdmaW5pc2gnIHx8IGV2ID09PSAncHJlZmluaXNoJykge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldik7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgb3RoZXIgdW5rbm93biBldmVudFxuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgW0VNSVREQVRBXShkYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzW1BJUEVTXSkge1xuICAgICAgICAgICAgaWYgKHAuZGVzdC53cml0ZShkYXRhKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXNbRElTQ0FSREVEXSA/IGZhbHNlIDogc3VwZXIuZW1pdCgnZGF0YScsIGRhdGEpO1xuICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBbRU1JVEVORF0oKSB7XG4gICAgICAgIGlmICh0aGlzW0VNSVRURURfRU5EXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpc1tFTUlUVEVEX0VORF0gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzW0FTWU5DXVxuICAgICAgICAgICAgPyAoZGVmZXIoKCkgPT4gdGhpc1tFTUlURU5EMl0oKSksIHRydWUpXG4gICAgICAgICAgICA6IHRoaXNbRU1JVEVORDJdKCk7XG4gICAgfVxuICAgIFtFTUlURU5EMl0oKSB7XG4gICAgICAgIGlmICh0aGlzW0RFQ09ERVJdKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpc1tERUNPREVSXS5lbmQoKTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXNbUElQRVNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuZGVzdC53cml0ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzW0RJU0NBUkRFRF0pXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpc1tQSVBFU10pIHtcbiAgICAgICAgICAgIHAuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdCgnZW5kJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdlbmQnKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIGFsbCBlbWl0dGVkIGRhdGEgb25jZVxuICAgICAqIHRoZSBzdHJlYW0gZW5kcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb2xsZWN0KCkge1xuICAgICAgICBjb25zdCBidWYgPSBPYmplY3QuYXNzaWduKFtdLCB7XG4gICAgICAgICAgICBkYXRhTGVuZ3RoOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgYnVmLmRhdGFMZW5ndGggPSAwO1xuICAgICAgICAvLyBzZXQgdGhlIHByb21pc2UgZmlyc3QsIGluIGNhc2UgYW4gZXJyb3IgaXMgcmFpc2VkXG4gICAgICAgIC8vIGJ5IHRyaWdnZXJpbmcgdGhlIGZsb3cgaGVyZS5cbiAgICAgICAgY29uc3QgcCA9IHRoaXMucHJvbWlzZSgpO1xuICAgICAgICB0aGlzLm9uKCdkYXRhJywgYyA9PiB7XG4gICAgICAgICAgICBidWYucHVzaChjKTtcbiAgICAgICAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgICAgICBidWYuZGF0YUxlbmd0aCArPSBjLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHA7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgZW1pdHRlZCBkYXRhXG4gICAgICogb25jZSB0aGUgc3RyZWFtIGVuZHMuXG4gICAgICpcbiAgICAgKiBOb3QgYWxsb3dlZCBvbiBvYmplY3RNb2RlIHN0cmVhbXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uY2F0KCkge1xuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29uY2F0IGluIG9iamVjdE1vZGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBhd2FpdCB0aGlzLmNvbGxlY3QoKTtcbiAgICAgICAgcmV0dXJuICh0aGlzW0VOQ09ESU5HXVxuICAgICAgICAgICAgPyBidWYuam9pbignJylcbiAgICAgICAgICAgIDogQnVmZmVyLmNvbmNhdChidWYsIGJ1Zi5kYXRhTGVuZ3RoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHZvaWQgUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIHN0cmVhbSBlbmRzLlxuICAgICAqL1xuICAgIGFzeW5jIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uKERFU1RST1lFRCwgKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignc3RyZWFtIGRlc3Ryb3llZCcpKSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGVyID0+IHJlamVjdChlcikpO1xuICAgICAgICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91cyBgZm9yIGF3YWl0IG9mYCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgY29udGludWUgZW1pdHRpbmcgYWxsIGNodW5rcyB1bnRpbCB0aGUgc3RyZWFtIHRlcm1pbmF0ZXMuXG4gICAgICovXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgLy8gc2V0IHRoaXMgdXAgZnJvbnQsIGluIGNhc2UgdGhlIGNvbnN1bWVyIGRvZXNuJ3QgY2FsbCBuZXh0KClcbiAgICAgICAgLy8gcmlnaHQgYXdheS5cbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgICAgIGxldCBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdG9wcGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IGZhbHNlLCB2YWx1ZTogcmVzIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcCgpO1xuICAgICAgICAgICAgbGV0IHJlc29sdmU7XG4gICAgICAgICAgICBsZXQgcmVqZWN0O1xuICAgICAgICAgICAgY29uc3Qgb25lcnIgPSAoZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZGF0YScsIG9uZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2VuZCcsIG9uZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihERVNUUk9ZRUQsIG9uZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25kYXRhID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2Vycm9yJywgb25lcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoREVTVFJPWUVELCBvbmRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgdmFsdWUsIGRvbmU6ICEhdGhpc1tFT0ZdIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdlcnJvcicsIG9uZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZGF0YScsIG9uZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoREVTVFJPWUVELCBvbmRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbmRlc3Ryb3kgPSAoKSA9PiBvbmVycihuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKERFU1RST1lFRCwgb25kZXN0cm95KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgb25lcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZSgnZGF0YScsIG9uZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICB0aHJvdzogc3RvcCxcbiAgICAgICAgICAgIHJldHVybjogc3RvcCxcbiAgICAgICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91cyBgZm9yIG9mYCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0aW9uIHdpbGwgdGVybWluYXRlIHdoZW4gdGhlIGludGVybmFsIGJ1ZmZlciBydW5zIG91dCwgZXZlblxuICAgICAqIGlmIHRoZSBzdHJlYW0gaGFzIG5vdCB5ZXQgdGVybWluYXRlZC5cbiAgICAgKi9cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgLy8gc2V0IHRoaXMgdXAgZnJvbnQsIGluIGNhc2UgdGhlIGNvbnN1bWVyIGRvZXNuJ3QgY2FsbCBuZXh0KClcbiAgICAgICAgLy8gcmlnaHQgYXdheS5cbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgICAgIGxldCBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLm9mZihFUlJPUiwgc3RvcCk7XG4gICAgICAgICAgICB0aGlzLm9mZihERVNUUk9ZRUQsIHN0b3ApO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2VuZCcsIHN0b3ApO1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RvcHBlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcCgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHN0b3AoKSA6IHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25jZSgnZW5kJywgc3RvcCk7XG4gICAgICAgIHRoaXMub25jZShFUlJPUiwgc3RvcCk7XG4gICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIHN0b3ApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgIHRocm93OiBzdG9wLFxuICAgICAgICAgICAgcmV0dXJuOiBzdG9wLFxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGEgc3RyZWFtLCBwcmV2ZW50aW5nIGl0IGZyb20gYmVpbmcgdXNlZCBmb3IgYW55IGZ1cnRoZXIgcHVycG9zZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzdHJlYW0gaGFzIGEgYGNsb3NlKClgIG1ldGhvZCwgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCBvblxuICAgICAqIGRlc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogQWZ0ZXIgZGVzdHJ1Y3Rpb24sIGFueSBhdHRlbXB0IHRvIHdyaXRlIGRhdGEsIHJlYWQgZGF0YSwgb3IgZW1pdCBtb3N0XG4gICAgICogZXZlbnRzIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIElmIGFuIGVycm9yIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYmUgZW1pdHRlZCBpbiBhblxuICAgICAqICdlcnJvcicgZXZlbnQuXG4gICAgICovXG4gICAgZGVzdHJveShlcikge1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoREVTVFJPWUVEKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbREVTVFJPWUVEXSA9IHRydWU7XG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IHRydWU7XG4gICAgICAgIC8vIHRocm93IGF3YXkgYWxsIGJ1ZmZlcmVkIGRhdGEsIGl0J3MgbmV2ZXIgY29taW5nIG91dFxuICAgICAgICB0aGlzW0JVRkZFUl0ubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdID0gMDtcbiAgICAgICAgY29uc3Qgd2MgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHdjLmNsb3NlID09PSAnZnVuY3Rpb24nICYmICF0aGlzW0NMT1NFRF0pXG4gICAgICAgICAgICB3Yy5jbG9zZSgpO1xuICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICAvLyBpZiBubyBlcnJvciB0byBlbWl0LCBzdGlsbCByZWplY3QgcGVuZGluZyBwcm9taXNlc1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmVtaXQoREVTVFJPWUVEKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgaXNTdHJlYW19XG4gICAgICpcbiAgICAgKiBGb3JtZXIgZXhwb3J0IGxvY2F0aW9uLCBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldCBpc1N0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNTdHJlYW07XG4gICAgfVxufVxuZXhwb3J0cy5NaW5pcGFzcyA9IE1pbmlwYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minipass/dist/commonjs/index.js\n");

/***/ })

};
;